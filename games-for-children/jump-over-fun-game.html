<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Fun Game ‚Äî Jump Over Obstacles!</title>
    <style>
        :root {
            --bg1: #51e0ff;
            --bg2: #c8f7ff;
            --ui: #1a1a2e;
            --accent: #ff4d6d;
            --accent2: #ffd166;
            --good: #2dd881;
            --bad: #ff595e;
            --white: #fff;
        }

        html,
        body {
            height: 100%;
            margin: 0;
            font-family: ui-rounded, system-ui, -apple-system, Segoe UI, Roboto,
                Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
            background: linear-gradient(180deg, var(--bg2), var(--bg1));
            color: var(--ui);
        }

        #wrap {
            position: relative;
            height: 100%;
            display: flex;
            flex-direction: column;
        }

        header {
            position: absolute;
            z-index: 4;
            width: 100%;
            pointer-events: none;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px 16px;
            box-sizing: border-box;
            mix-blend-mode: normal;
        }

        .title {
            pointer-events: auto;
            font-weight: 900;
            letter-spacing: 0.5px;
            background: linear-gradient(90deg, #ff6b6b, #ffd166, #06d6a0, #4cc9f0);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            text-shadow: 0 2px 0 rgba(0, 0, 0, 0.08);
            user-select: none;
            font-size: clamp(20px, 4vw, 36px);
        }

        .hud {
            display: flex;
            gap: 10px;
            align-items: center;
            pointer-events: auto;
            background: rgba(255, 255, 255, 0.55);
            border: 2px solid rgba(0, 0, 0, 0.08);
            padding: 8px 12px;
            border-radius: 14px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.08);
            backdrop-filter: blur(6px);
        }

        .hud .chip {
            font-weight: 800;
            padding: 6px 10px;
            border-radius: 999px;
            background: #ffffffaa;
        }

        .btn {
            appearance: none;
            border: 0;
            background: var(--accent);
            color: #fff;
            font-weight: 800;
            padding: 10px 14px;
            border-radius: 14px;
            cursor: pointer;
            box-shadow: 0 8px 20px rgba(255, 77, 109, 0.35);
            transition: transform 0.06s ease, box-shadow 0.2s;
        }

        .btn:active {
            transform: translateY(1px) scale(0.99);
        }

        #game {
            width: 100%;
            height: 100%;
            display: block;
        }

        #overlay {
            position: absolute;
            inset: 0;
            display: grid;
            place-items: center;
            z-index: 3;
            pointer-events: none;
        }

        .panel {
            pointer-events: auto;
            background: linear-gradient(180deg, #ffffffee, #ffffffcc);
            border: 2px solid rgba(0, 0, 0, 0.1);
            border-radius: 22px;
            padding: 20px;
            text-align: center;
            box-shadow: 0 16px 50px rgba(0, 0, 0, 0.18);
            max-width: 520px;
            margin: 20px;
        }

        .panel h1 {
            margin: 0.2rem 0 0;
            font-size: clamp(28px, 6vw, 48px);
        }

        .subtitle {
            opacity: 0.9;
            margin: 0.3rem 0 1rem;
            font-weight: 600;
        }

        .stack {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
        }

        .k {
            padding: 6px 10px;
            border-radius: 999px;
            background: #00000010;
            font-weight: 700;
            font-size: 14px;
        }

        .retry {
            background: var(--good);
            box-shadow: 0 10px 22px rgba(45, 216, 129, 0.35);
        }

        .mute {
            background: var(--accent2);
            color: #000;
            box-shadow: 0 10px 22px rgba(255, 209, 102, 0.35);
        }

        footer {
            position: absolute;
            bottom: 8px;
            left: 0;
            right: 0;
            display: flex;
            justify-content: center;
            z-index: 2;
            pointer-events: none;
            font-size: 12px;
            opacity: 0.7;
            font-weight: 600;
        }

        .tip {
            pointer-events: auto;
            background: #ffffff80;
            padding: 6px 10px;
            border-radius: 999px;
            border: 1px solid rgba(0, 0, 0, 0.08);
        }

        .hidden {
            display: none !important;
        }
    </style>
</head>

<body>
    <div id="wrap">
        <header>
            <div class="title">üåà Fun Game</div>
            <div class="hud" role="status" aria-live="polite">
                <div class="chip">Score: <span id="score">0</span></div>
                <div class="chip">Best: <span id="best">0</span></div>
                <button class="btn mute" id="muteBtn" aria-pressed="false" title="Toggle sounds (M)">
                    üîä Sound
                </button>
                <button class="btn" id="pauseBtn" title="Pause/Resume (P)">
                    ‚è∏Ô∏è Pause
                </button>
            </div>
        </header>

        <canvas id="game" aria-label="Fun Game canvas"></canvas>

        <div id="overlay">
            <div class="panel" id="startPanel">
                <h1>Jump over obstacles!</h1>
                <div class="subtitle">
                    Survive as long as possible. Speed keeps increasing. üëÄ
                </div>
                <div class="stack" style="margin-bottom: 14px">
                    <span class="k">Jump: Space / ‚Üë / Tap</span>
                    <span class="k">Pause: P</span>
                    <span class="k">Mute: M</span>
                    <span class="k">Retry: R</span>
                </div>
                <button class="btn retry" id="startBtn">‚ñ∂Ô∏è Start Playing</button>
            </div>
            <div class="panel hidden" id="gameOverPanel">
                <h1 style="color: var(--bad)">üí• Oops!</h1>
                <div class="subtitle">You hit something silly. Try again!</div>
                <div style="font-weight: 800; margin-bottom: 10px">
                    Score: <span id="finalScore">0</span> ‚Ä¢ Best:
                    <span id="finalBest">0</span>
                </div>
                <div class="stack">
                    <button class="btn retry" id="retryBtn">üîÑ Retry</button>
                    <button class="btn mute" id="shareBtn">üì£ Share Score</button>
                </div>
            </div>
        </div>

        <footer>
            <div class="tip">Pro tip: hold jump for a higher hop. Have fun! üéà</div>
        </footer>
    </div>

    <script>
        /* ========= Utility & Setup ========= */
        const canvas = document.getElementById("game");
        const ctx = canvas.getContext("2d", { alpha: false });
        const dpr = Math.max(1, window.devicePixelRatio || 1);
        let W = 0,
            H = 0;

        function resize() {
            const cs = getComputedStyle(canvas);
            const w = canvas.clientWidth || parseInt(cs.width, 10);
            const h = canvas.clientHeight || parseInt(cs.height, 10);
            W = Math.floor(w * dpr);
            H = Math.floor(h * dpr);
            canvas.width = W;
            canvas.height = H;
            ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // draw in CSS pixels
            groundY = Math.floor((H / dpr) * 0.78);
        }
        window.addEventListener("resize", resize);

        /* ========= Sounds (Web Audio, all inline) ========= */
        let audioCtx = null;
        let muted = false;
        function ensureAudio() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            }
        }
        function beep({
            freq = 600,
            dur = 0.08,
            type = "square",
            vol = 0.15,
            slide = -400,
        } = {}) {
            if (muted) return;
            ensureAudio();
            const t0 = audioCtx.currentTime;
            const o = audioCtx.createOscillator();
            const g = audioCtx.createGain();
            o.type = type;
            o.frequency.setValueAtTime(freq, t0);
            if (slide)
                o.frequency.exponentialRampToValueAtTime(
                    Math.max(60, freq + slide),
                    t0 + dur
                );
            g.gain.setValueAtTime(vol, t0);
            g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);
            o.connect(g).connect(audioCtx.destination);
            o.start(t0);
            o.stop(t0 + dur);
        }
        function boing() {
            beep({ freq: 400, type: "sawtooth", dur: 0.18, slide: -250, vol: 0.2 });
            setTimeout(
                () =>
                    beep({
                        freq: 220,
                        type: "triangle",
                        dur: 0.12,
                        slide: 140,
                        vol: 0.12,
                    }),
                40
            );
        }
        function crash() {
            if (muted) return;
            ensureAudio();
            const t0 = audioCtx.currentTime;
            const noise = audioCtx.createBufferSource();
            const buffer = audioCtx.createBuffer(
                1,
                audioCtx.sampleRate * 0.25,
                audioCtx.sampleRate
            );
            const data = buffer.getChannelData(0);
            for (let i = 0; i < data.length; i++)
                data[i] = (Math.random() * 2 - 1) * (1 - i / data.length);
            noise.buffer = buffer;
            const g = audioCtx.createGain();
            g.gain.value = 0.25;
            const bp = audioCtx.createBiquadFilter();
            bp.type = "bandpass";
            bp.frequency.value = 240;
            noise.connect(bp).connect(g).connect(audioCtx.destination);
            noise.start(t0);
            noise.stop(t0 + 0.25);
        }
        function coin() {
            beep({ freq: 900, type: "square", dur: 0.06, slide: 300, vol: 0.12 });
        }

        /* ========= Game State ========= */
        let running = false;
        let paused = false;
        let gameOver = false;
        let tPrev = 0;
        let elapsed = 0;

        let groundY = 0;
        const gravity = 0.8; // pixels per frame^2 (in CSS px)
        const jumpV = -14.5; // jump impulse
        let speedBase = 5.2; // base horizontal speed
        let speed = speedBase;
        const accel = 0.00035; // speed increase per ms
        let obstacleTimer = 0;
        let obstacleEvery = 1400; // ms, will tighten slightly with speed

        let score = 0;
        let best = Number(localStorage.getItem("funGameBest") || 0);

        /* ========= Entities ========= */
        const player = {
            x: 90,
            y: 0,
            w: 42,
            h: 48,
            vy: 0,
            onGround: true,
            blinkT: 0,
        };

        function resetGame() {
            running = true;
            paused = false;
            gameOver = false;
            document.getElementById("startPanel").classList.add("hidden");
            document.getElementById("gameOverPanel").classList.add("hidden");
            tPrev = performance.now();
            elapsed = 0;
            speed = speedBase;
            obstacleTimer = 0;
            score = 0;
            player.vy = 0;
            player.onGround = true;
            player.y = groundY - player.h;
            obstacles.length = 0;
            parallaxReset();
            updateHUD();
        }

        const obstacles = [];
        function spawnObstacle() {
            // Randomize size and type (cartoon blocks with faces)
            const types = ["box", "cone", "jelly", "roller"];
            const type = types[(Math.random() * types.length) | 0];
            let w = 36,
                h = 36,
                y = groundY - 36;
            if (type === "cone") {
                w = 28;
                h = 40;
                y = groundY - h;
            }
            if (type === "jelly") {
                w = 38;
                h = 30;
                y = groundY - h - 2;
            }
            if (type === "roller") {
                w = 44;
                h = 32;
                y = groundY - h;
            }
            obstacles.push({
                x: canvas.width / dpr + 20,
                y,
                w,
                h,
                type,
                t: 0,
                spin: Math.random() * Math.PI * 2,
            });
        }

        /* ========= Parallax Background ========= */
        const layers = [
            { speed: 0.15, items: [], color: "#e6f7ff" }, // clouds far
            { speed: 0.35, items: [], color: "#bde0fe" }, // clouds near
            { speed: 0.6, items: [], color: "#a2d2ff" }, // hills far
            { speed: 1.0, items: [], color: "#72efdd" }, // hills near
            { speed: 1.6, items: [], color: "#8ac926" }, // grass
        ];

        function parallaxReset() {
            layers.forEach((l, idx) => {
                l.items.length = 0;
                const width = canvas.width / dpr;
                // Seed some shapes across the width
                for (let x = 0; x < width + 300; x += 120 + Math.random() * 160) {
                    l.items.push({
                        x,
                        y: 0,
                        n: idx < 2 ? "cloud" : "hill",
                        s: 0.6 + Math.random() * 1.4,
                        off: Math.random() * 1000,
                    });
                }
            });
        }

        function drawParallax(dt) {
            const width = canvas.width / dpr;
            // Sky gradient
            const g = ctx.createLinearGradient(0, 0, 0, H / dpr);
            g.addColorStop(0, "#c8f7ff");
            g.addColorStop(1, "#51e0ff");
            ctx.fillStyle = g;
            ctx.fillRect(0, 0, width, H / dpr);

            // Sun
            ctx.save();
            ctx.globalAlpha = 0.85;
            ctx.beginPath();
            ctx.arc(width - 100, 90, 50, 0, Math.PI * 2);
            ctx.fillStyle = "#ffd166";
            ctx.fill();
            ctx.restore();

            // Layers
            const groundLine = groundY;
            layers.forEach((layer, i) => {
                const s = (speed * layer.speed * dt) / 16.666;
                layer.items.forEach((item) => {
                    item.x -= s * 4; // layer movement
                    // wrap-around
                    if (item.x < -200) item.x += width + 400;

                    if (item.n === "cloud") {
                        const y =
                            40 +
                            (i === 0 ? 30 : 80) +
                            Math.sin((elapsed + item.off) * 0.0005) * 10;
                        drawCloud(
                            item.x,
                            y,
                            18 * item.s * (i === 0 ? 0.9 : 1.2),
                            layer.color,
                            0.8 - i * 0.2
                        );
                    } else {
                        const baseY = groundLine + (i === 2 ? 18 : 0);
                        drawHill(
                            item.x,
                            baseY,
                            90 * item.s * (i === 2 ? 1.2 : 1),
                            layer.color
                        );
                    }
                });
            });

            // Ground stripe
            ctx.fillStyle = "#34d399";
            ctx.fillRect(0, groundLine, width, H / dpr - groundLine);
            // Grass blades
            for (let x = 0; x < width; x += 16) {
                ctx.beginPath();
                ctx.moveTo(x, groundLine);
                ctx.quadraticCurveTo(x + 4, groundLine - 6, x + 8, groundLine);
                ctx.strokeStyle = "#2bbd82";
                ctx.lineWidth = 2;
                ctx.stroke();
            }
        }

        function drawCloud(x, y, r, c, alpha = 1) {
            ctx.save();
            ctx.globalAlpha = alpha;
            ctx.fillStyle = c;
            ctx.beginPath();
            ctx.arc(x, y, r, 0, Math.PI * 2);
            ctx.arc(x + r * 0.8, y + 4, r * 0.8, 0, Math.PI * 2);
            ctx.arc(x - r * 0.8, y + 6, r * 0.7, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
        }
        function drawHill(x, baseY, w, c) {
            ctx.save();
            ctx.fillStyle = c;
            ctx.beginPath();
            ctx.moveTo(x - w, baseY);
            ctx.quadraticCurveTo(x, baseY - w * 0.8, x + w, baseY);
            ctx.closePath();
            ctx.fill();
            ctx.restore();
        }

        /* ========= Drawing ========= */
        function drawPlayer(p, t) {
            const blink = ((t / 800) | 0) % 4 === 0; // occasional blink
            // Body
            const r = 12;
            roundRect(ctx, p.x, p.y, p.w, p.h, r, "#ff90e8", "#ff4d6d");

            // Belly
            roundRect(
                ctx,
                p.x + 8,
                p.y + 18,
                p.w - 16,
                18,
                8,
                "#ffe9f6",
                "#ffc4dd"
            );

            // Eyes
            ctx.fillStyle = "#222";
            const eyeY = p.y + 14;
            ctx.beginPath();
            ctx.arc(p.x + 14, eyeY, 3, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(p.x + p.w - 14, eyeY, 3, 0, Math.PI * 2);
            ctx.fill();

            // Blink overlay
            if (blink) {
                ctx.fillStyle = "#ff90e8";
                ctx.fillRect(p.x + 10, eyeY - 4, 8, 8);
                ctx.fillRect(p.x + p.w - 18, eyeY - 4, 8, 8);
            }

            // Smile
            ctx.beginPath();
            ctx.arc(p.x + p.w / 2, p.y + 28, 6, 0, Math.PI);
            ctx.strokeStyle = "#1a1a2e";
            ctx.lineWidth = 2;
            ctx.stroke();

            // Feet wiggle
            const k = Math.max(0, Math.min(1, (groundY - (p.y + p.h)) / 8));
            const swing = Math.sin(elapsed * 0.02) * (p.onGround ? 2 : 6);
            ctx.fillStyle = "#1a1a2e";
            ctx.fillRect(p.x + 8 + swing, p.y + p.h - 4, 10, 4);
            ctx.fillRect(p.x + p.w - 18 - swing, p.y + p.h - 4, 10, 4);
        }

        function drawObstacle(o) {
            const { x, y, w, h, type } = o;
            if (type === "box") {
                roundRect(ctx, x, y, w, h, 8, "#ffd166", "#f4a261");
                drawFace(x, y, w, h);
            } else if (type === "cone") {
                ctx.fillStyle = "#ff6b6b";
                ctx.beginPath();
                ctx.moveTo(x + w / 2, y);
                ctx.lineTo(x + w, y + h);
                ctx.lineTo(x, y + h);
                ctx.closePath();
                ctx.fill();
                drawFace(x, y + 10, w, h - 10);
            } else if (type === "jelly") {
                roundRect(ctx, x, y, w, h, 12, "#90e0ef", "#48cae4");
                drawFace(x, y, w, h);
                // wobble
                ctx.fillStyle = "#48cae4";
                ctx.fillRect(x, y + h - 6, w, 6);
            } else if (type === "roller") {
                const r = h / 2;
                const cx = x + w / 2,
                    cy = y + h / 2;
                ctx.save();
                ctx.translate(cx, cy);
                ctx.rotate(o.spin);
                ctx.fillStyle = "#bde0fe";
                ctx.beginPath();
                ctx.arc(0, 0, r, 0, Math.PI * 2);
                ctx.fill();
                ctx.fillStyle = "#1a1a2e";
                ctx.fillRect(-2, -r, 4, r * 2);
                ctx.restore();
            }
        }
        function drawFace(x, y, w, h) {
            ctx.fillStyle = "#1a1a2e";
            ctx.beginPath();
            ctx.arc(x + w * 0.35, y + h * 0.35, 3, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(x + w * 0.65, y + h * 0.35, 3, 0, Math.PI * 2);
            ctx.fill();
            ctx.beginPath();
            ctx.arc(x + w * 0.5, y + h * 0.6, 6, 0, Math.PI);
            ctx.strokeStyle = "#1a1a2e";
            ctx.lineWidth = 2;
            ctx.stroke();
        }

        function roundRect(ctx, x, y, w, h, r, fill, stroke) {
            ctx.beginPath();
            ctx.moveTo(x + r, y);
            ctx.arcTo(x + w, y, x + w, y + h, r);
            ctx.arcTo(x + w, y + h, x, y + h, r);
            ctx.arcTo(x, y + h, x, y, r);
            ctx.arcTo(x, y, x + w, y, r);
            if (fill) {
                ctx.fillStyle = fill;
                ctx.fill();
            }
            if (stroke) {
                ctx.strokeStyle = stroke;
                ctx.lineWidth = 2;
                ctx.stroke();
            }
        }

        /* ========= Physics & Update ========= */
        function update(dt) {
            if (!running || paused) return;

            elapsed += dt;
            speed += dt * accel; // speed ramps up over time
            obstacleTimer += dt;

            // tighten spawn interval a little as speed grows (min 700ms)
            const targetEvery = Math.max(
                700,
                obstacleEvery - (speed - speedBase) * 60
            );
            if (obstacleTimer > targetEvery) {
                obstacleTimer = 0;
                spawnObstacle();
            }

            // Player physics
            player.vy += gravity;
            player.y += player.vy;
            if (player.y + player.h >= groundY) {
                player.y = groundY - player.h;
                player.vy = 0;
                player.onGround = true;
            } else {
                player.onGround = false;
            }

            // Obstacles
            for (let i = obstacles.length - 1; i >= 0; i--) {
                const o = obstacles[i];
                o.x -= speed;
                o.t += dt;
                if (o.type === "roller") {
                    o.spin += 0.08 * (speed / 6);
                }
                if (o.x + o.w < -40) obstacles.splice(i, 1);
            }

            // Collisions (simple AABB)
            for (const o of obstacles) {
                if (rectsOverlap(player, o, 8)) {
                    endGame();
                    return;
                }
            }

            // Score
            score += dt * 0.01 * (1 + (speed - speedBase) * 0.15);
            if ((score | 0) % 100 === 0) {
                coin();
            } // cheerful tick
        }

        function rectsOverlap(a, b, pad = 0) {
            return !(
                a.x + a.w - pad < b.x ||
                a.x + pad > b.x + b.w ||
                a.y + a.h - pad < b.y ||
                a.y + pad > b.y + b.h
            );
        }

        /* ========= Render Loop ========= */
        function render() {
            // Background + ground
            drawParallax(16.666);

            // Draw obstacles
            obstacles.forEach(drawObstacle);

            // Draw player
            drawPlayer(player, elapsed);

            // HUD score (also in header)
            ctx.save();
            ctx.globalAlpha = 0.08;
            ctx.fillStyle = "#000";
            ctx.font = "900 120px/1 system-ui, -apple-system, Segoe UI, Roboto";
            ctx.textAlign = "center";
            ctx.fillText(score | 0, canvas.width / dpr / 2, 200);
            ctx.restore();
        }

        /* ========= Game Flow ========= */
        function loop(ts) {
            const dt = Math.min(40, ts - tPrev || 16.666);
            tPrev = ts;

            if (running && !paused && !gameOver) {
                update(dt);
            }
            render();
            updateHUD();
            requestAnimationFrame(loop);
        }
        function updateHUD() {
            document.getElementById("score").textContent = score | 0;
            document.getElementById("best").textContent = best;
        }

        function endGame() {
            gameOver = true;
            running = false;
            best = Math.max(best, score | 0);
            localStorage.setItem("funGameBest", best);
            document.getElementById("finalScore").textContent = score | 0;
            document.getElementById("finalBest").textContent = best;
            document.getElementById("gameOverPanel").classList.remove("hidden");
            crash();
        }

        /* ========= Controls ========= */
        function jump() {
            if (gameOver) return;
            if (!running) {
                resetGame();
                boing();
                return;
            }
            if (paused) {
                togglePause(false);
                return;
            }
            if (player.onGround) {
                player.vy = jumpV;
                player.onGround = false;
                boing();
            } else {
                // Held jump for a bit of extra airtime
                player.vy -= 0.35;
            }
        }
        function togglePause(force) {
            if (!running || gameOver) return;
            const want = typeof force === "boolean" ? force : !paused;
            paused = want;
            document.getElementById("pauseBtn").textContent = paused
                ? "‚ñ∂Ô∏è Resume"
                : "‚è∏Ô∏è Pause";
        }

        document.addEventListener("keydown", (e) => {
            if (e.repeat) return;
            if (e.code === "Space" || e.code === "ArrowUp") {
                e.preventDefault();
                jump();
            }
            if (e.key === "p" || e.key === "P") {
                togglePause();
            }
            if (e.key === "r" || e.key === "R") {
                if (gameOver) resetGame();
            }
            if (e.key === "m" || e.key === "M") {
                toggleMute();
            }
        });
        let touchJumping = false;
        canvas.addEventListener("pointerdown", (e) => {
            touchJumping = true;
            jump();
        });
        canvas.addEventListener("pointerup", (e) => {
            touchJumping = false;
        });

        function toggleMute() {
            muted = !muted;
            document.getElementById("muteBtn").textContent = muted
                ? "üîá Muted"
                : "üîä Sound";
            document
                .getElementById("muteBtn")
                .setAttribute("aria-pressed", String(muted));
        }

        /* ========= UI Buttons ========= */
        document.getElementById("startBtn").addEventListener("click", () => {
            resetGame();
            beep({ freq: 700, type: "triangle", dur: 0.08, slide: 100 });
        });
        document.getElementById("retryBtn").addEventListener("click", () => {
            resetGame();
        });
        document
            .getElementById("pauseBtn")
            .addEventListener("click", () => togglePause());
        document
            .getElementById("muteBtn")
            .addEventListener("click", () => toggleMute());
        document
            .getElementById("shareBtn")
            .addEventListener("click", async () => {
                const sc = score | 0;
                const text = `I scored ${sc} in üåà Fun Game! Can you beat me?`;
                if (navigator.share) {
                    try {
                        await navigator.share({ text, title: "Fun Game" });
                    } catch { }
                } else {
                    try {
                        await navigator.clipboard.writeText(text);
                        alert("Copied to clipboard! Paste it anywhere to brag üéâ");
                    } catch {
                        alert(text);
                    }
                }
            });

        /* ========= Init ========= */
        resize();
        parallaxReset();
        requestAnimationFrame((t) => {
            tPrev = t;
            loop(t);
        });

        /* ========= Accessibility boost (focus-trap-ish) ========= */
        document.getElementById("startBtn").focus();
    </script>
</body>

</html>